# åç«¯å¼€å‘æŒ‡å—

## ğŸ“š å¯¼èˆª

[â† è¿”å›é¡¹ç›®æ¦‚è§ˆ](./01-é¡¹ç›®æ¦‚è§ˆ.md) | [å‰ç«¯å¼€å‘æŒ‡å— â†’](./03-å‰ç«¯å¼€å‘æŒ‡å—.md)

---

## ğŸ¯ åç«¯æ¶æ„æ¦‚è¿°

NO-CRM åç«¯é‡‡ç”¨ NestJS æ¡†æ¶ï¼Œæ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªä¸šåŠ¡åŠŸèƒ½éƒ½æ˜¯ç‹¬ç«‹çš„æ¨¡å—ã€‚

### æ ¸å¿ƒæ¨¡å—

```
backend/src/
â”œâ”€â”€ auth/           # è®¤è¯æ¨¡å—ï¼ˆJWTï¼‰
â”œâ”€â”€ customers/      # å®¢æˆ·ç®¡ç†
â”œâ”€â”€ leads/          # çº¿ç´¢ç®¡ç†
â”œâ”€â”€ activities/     # è·Ÿè¿›è®°å½•
â”œâ”€â”€ tasks/          # ä»»åŠ¡ç®¡ç†
â””â”€â”€ common/         # å…¬å…±æœåŠ¡
```

---

## ğŸ—ï¸ NestJS åŸºç¡€

### æ¨¡å—ï¼ˆModuleï¼‰

NestJS ä½¿ç”¨æ¨¡å—ç»„ç»‡ä»£ç ï¼Œæ¯ä¸ªæ¨¡å—éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åŠŸèƒ½å•å…ƒã€‚

```typescript
// customers.module.ts
@Module({
  controllers: [CustomersController],  // æ§åˆ¶å™¨
  providers: [CustomersService, JsonStorageService],  // æœåŠ¡
})
export class CustomersModule {}
```

### æ§åˆ¶å™¨ï¼ˆControllerï¼‰

å¤„ç† HTTP è¯·æ±‚ï¼Œå®šä¹‰è·¯ç”±ã€‚

```typescript
// customers.controller.ts
@Controller('customers')  // è·¯ç”±å‰ç¼€
@UseGuards(JwtAuthGuard)  // ä½¿ç”¨ JWT å®ˆå«
export class CustomersController {
  constructor(private readonly customersService: CustomersService) {}

  @Get()  // GET /api/customers
  findAll(@Request() req: any) {
    return this.customersService.findAll(req.user.id, req.user.role);
  }

  @Post()  // POST /api/customers
  create(@Body(ValidationPipe) dto: CreateCustomerDto, @Request() req: any) {
    return this.customersService.create(dto, req.user.id);
  }
}
```

### æœåŠ¡ï¼ˆServiceï¼‰

ä¸šåŠ¡é€»è¾‘å¤„ç†ã€‚

```typescript
// customers.service.ts
@Injectable()
export class CustomersService {
  constructor(private readonly storageService: JsonStorageService) {}

  create(dto: CreateCustomerDto, userId: string): Customer {
    const customer: Customer = {
      id: uuidv4(),
      ...dto,
      ownerId: userId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    return this.storageService.create('customers', customer);
  }

  findAll(userId: string, userRole: string): Customer[] {
    const customers = this.storageService.read<Customer>('customers');
    if (userRole === 'admin') return customers;
    return customers.filter(c => c.ownerId === userId);
  }
}
```

---

## ğŸ” è®¤è¯ç³»ç»Ÿ

### JWT è®¤è¯æµç¨‹

```
1. ç”¨æˆ·ç™»å½• â†’ POST /api/auth/login
   â†“
2. éªŒè¯é‚®ç®±å¯†ç 
   â†“
3. ç”Ÿæˆ JWT Token
   â†“
4. è¿”å› Token ç»™å‰ç«¯
   â†“
5. å‰ç«¯æºå¸¦ Token è®¿é—®å—ä¿æŠ¤æ¥å£
   â†“
6. JWT å®ˆå«éªŒè¯ Token
   â†“
7. è¿”å›æ•°æ®
```

### å®ç°ä»£ç 

#### 1. ç”¨æˆ·ç™»å½•

```typescript
// auth.service.ts
async login(loginDto: LoginDto) {
  // 1. æŸ¥æ‰¾ç”¨æˆ·
  const users = this.storageService.read<User>('users');
  const user = users.find(u => u.email === loginDto.email);
  
  if (!user) {
    throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
  }

  // 2. éªŒè¯å¯†ç 
  const isPasswordValid = await bcrypt.compare(loginDto.password, user.password);
  if (!isPasswordValid) {
    throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
  }

  // 3. ç”Ÿæˆ Token
  const token = this.jwtService.sign({ 
    sub: user.id, 
    email: user.email,
    role: user.role 
  });

  // 4. è¿”å›ç”¨æˆ·ä¿¡æ¯å’Œ Token
  const { password, ...userWithoutPassword } = user;
  return { user: userWithoutPassword, token };
}
```

#### 2. JWT ç­–ç•¥

```typescript
// jwt.strategy.ts
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'your-secret-key',
    });
  }

  async validate(payload: any) {
    const user = await this.authService.validateUser(payload.sub);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;  // ä¼šè¢«æ³¨å…¥åˆ° @Request() req.user
  }
}
```

#### 3. ä½¿ç”¨ JWT å®ˆå«

```typescript
// åœ¨æ§åˆ¶å™¨ä¸­ä½¿ç”¨
@Controller('customers')
@UseGuards(JwtAuthGuard)  // ä¿æŠ¤æ•´ä¸ªæ§åˆ¶å™¨
export class CustomersController {
  // æ‰€æœ‰æ–¹æ³•éƒ½éœ€è¦ç™»å½•
}

// æˆ–è€…åªä¿æŠ¤ç‰¹å®šæ–¹æ³•
@Get()
@UseGuards(JwtAuthGuard)
findAll() {
  // ...
}
```

---

## ğŸ’¾ JSON æ•°æ®å­˜å‚¨

### JsonStorageService

è¿™æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„æœåŠ¡ï¼Œç”¨äºè¯»å†™ JSON æ–‡ä»¶ã€‚

#### æ ¸å¿ƒæ–¹æ³•

```typescript
export class JsonStorageService {
  // è¯»å–æ•°æ®
  read<T>(fileName: string): T[] {
    const filePath = path.join(this.dataPath, `${fileName}.json`);
    if (!fs.existsSync(filePath)) return [];
    const data = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(data);
  }

  // å†™å…¥æ•°æ®
  write<T>(fileName: string, data: T[]): void {
    const filePath = path.join(this.dataPath, `${fileName}.json`);
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
  }

  // åˆ›å»ºè®°å½•
  create<T extends { id: string }>(fileName: string, item: T): T {
    const items = this.read<T>(fileName);
    items.push(item);
    this.write(fileName, items);
    return item;
  }

  // æ›´æ–°è®°å½•
  update<T extends { id: string }>(fileName: string, id: string, updates: Partial<T>): T | null {
    const items = this.read<T>(fileName);
    const index = items.findIndex(item => item.id === id);
    if (index === -1) return null;

    items[index] = { ...items[index], ...updates };
    this.write(fileName, items);
    return items[index];
  }

  // åˆ é™¤è®°å½•
  delete<T extends { id: string }>(fileName: string, id: string): boolean {
    const items = this.read<T>(fileName);
    const filteredItems = items.filter(item => item.id !== id);
    if (filteredItems.length === items.length) return false;

    this.write(fileName, filteredItems);
    return true;
  }
}
```

#### ä½¿ç”¨ç¤ºä¾‹

```typescript
@Injectable()
export class CustomersService {
  constructor(private readonly storageService: JsonStorageService) {}

  // åˆ›å»ºå®¢æˆ·
  create(dto: CreateCustomerDto, userId: string): Customer {
    const customer: Customer = {
      id: uuidv4(),  // ç”Ÿæˆå”¯ä¸€ ID
      ...dto,
      ownerId: userId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    // ä¿å­˜åˆ° customers.json
    return this.storageService.create('customers', customer);
  }

  // è·å–æ‰€æœ‰å®¢æˆ·
  findAll(userId: string, userRole: string): Customer[] {
    const customers = this.storageService.read<Customer>('customers');
    
    // æƒé™æ§åˆ¶ï¼šç®¡ç†å‘˜çœ‹æ‰€æœ‰ï¼Œé”€å”®çœ‹è‡ªå·±çš„
    if (userRole === 'admin') return customers;
    return customers.filter(c => c.ownerId === userId);
  }

  // æ›´æ–°å®¢æˆ·
  update(id: string, dto: UpdateCustomerDto): Customer {
    const updated = this.storageService.update<Customer>('customers', id, {
      ...dto,
      updatedAt: new Date().toISOString(),
    } as Partial<Customer>);
    
    if (!updated) throw new NotFoundException('å®¢æˆ·ä¸å­˜åœ¨');
    return updated;
  }

  // åˆ é™¤å®¢æˆ·
  remove(id: string): void {
    const deleted = this.storageService.delete('customers', id);
    if (!deleted) throw new NotFoundException('å®¢æˆ·ä¸å­˜åœ¨');
  }
}
```

---

## ğŸ“ æ•°æ®éªŒè¯ï¼ˆDTOï¼‰

ä½¿ç”¨ `class-validator` è¿›è¡Œæ•°æ®éªŒè¯ã€‚

### åˆ›å»º DTO

```typescript
// dto/customer.dto.ts
export class CreateCustomerDto {
  @IsString()
  @IsNotEmpty()
  name: string;

  @IsString()
  @IsNotEmpty()
  phone: string;

  @IsString()
  @IsOptional()
  company?: string;

  @IsArray()
  @IsOptional()
  tags?: string[];
}

export class UpdateCustomerDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  phone?: string;
  
  // ... å…¶ä»–å­—æ®µ
}
```

### åœ¨æ§åˆ¶å™¨ä¸­ä½¿ç”¨

```typescript
@Post()
create(@Body(ValidationPipe) dto: CreateCustomerDto, @Request() req: any) {
  return this.customersService.create(dto, req.user.id);
}
```

ValidationPipe ä¼šè‡ªåŠ¨éªŒè¯ DTOï¼Œå¦‚æœéªŒè¯å¤±è´¥ä¼šè¿”å› 400 é”™è¯¯ã€‚

---

## ğŸ¯ æ–°å¢ä¸šåŠ¡æ¨¡å—

### æ­¥éª¤æŒ‡å—

å‡è®¾ä½ è¦æ–°å¢ä¸€ä¸ª"é”€å”®æœºä¼š"æ¨¡å—ã€‚

#### 1. å®šä¹‰æ•°æ®æ¥å£

```typescript
// common/interfaces.ts
export interface Opportunity {
  id: string;
  title: string;
  amount: number;
  stage: 'negotiation' | 'proposal' | 'closing' | 'won' | 'lost';
  customerId: string;
  ownerId: string;
  createdAt: string;
  updatedAt: string;
}
```

#### 2. åˆ›å»º DTO

```typescript
// opportunities/dto/opportunity.dto.ts
export class CreateOpportunityDto {
  @IsString()
  @IsNotEmpty()
  title: string;

  @IsNumber()
  @Min(0)
  amount: number;

  @IsEnum(['negotiation', 'proposal', 'closing', 'won', 'lost'])
  stage: string;

  @IsString()
  @IsNotEmpty()
  customerId: string;
}

export class UpdateOpportunityDto {
  // æ‰€æœ‰å­—æ®µéƒ½æ˜¯å¯é€‰çš„
  @IsString()
  @IsOptional()
  title?: string;

  @IsNumber()
  @IsOptional()
  amount?: number;

  @IsEnum(['negotiation', 'proposal', 'closing', 'won', 'lost'])
  @IsOptional()
  stage?: string;
}
```

#### 3. åˆ›å»º Service

```typescript
// opportunities/opportunities.service.ts
@Injectable()
export class OpportunitiesService {
  constructor(private readonly storageService: JsonStorageService) {}

  create(dto: CreateOpportunityDto, userId: string): Opportunity {
    const opportunity: Opportunity = {
      id: uuidv4(),
      ...dto,
      ownerId: userId,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    return this.storageService.create('opportunities', opportunity);
  }

  findAll(userId: string, userRole: string): Opportunity[] {
    const opportunities = this.storageService.read<Opportunity>('opportunities');
    if (userRole === 'admin') return opportunities;
    return opportunities.filter(o => o.ownerId === userId);
  }

  findOne(id: string): Opportunity {
    const opportunity = this.storageService.findById<Opportunity>('opportunities', id);
    if (!opportunity) throw new NotFoundException('é”€å”®æœºä¼šä¸å­˜åœ¨');
    return opportunity;
  }

  update(id: string, dto: UpdateOpportunityDto): Opportunity {
    const updated = this.storageService.update<Opportunity>('opportunities', id, {
      ...dto,
      updatedAt: new Date().toISOString(),
    } as Partial<Opportunity>);
    
    if (!updated) throw new NotFoundException('æ›´æ–°å¤±è´¥');
    return updated;
  }

  remove(id: string): void {
    const deleted = this.storageService.delete('opportunities', id);
    if (!deleted) throw new NotFoundException('åˆ é™¤å¤±è´¥');
  }
}
```

#### 4. åˆ›å»º Controller

```typescript
// opportunities/opportunities.controller.ts
@Controller('opportunities')
@UseGuards(JwtAuthGuard)
export class OpportunitiesController {
  constructor(private readonly opportunitiesService: OpportunitiesService) {}

  @Post()
  create(@Body(ValidationPipe) dto: CreateOpportunityDto, @Request() req: any) {
    return this.opportunitiesService.create(dto, req.user.id);
  }

  @Get()
  findAll(@Request() req: any) {
    return this.opportunitiesService.findAll(req.user.id, req.user.role);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.opportunitiesService.findOne(id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body(ValidationPipe) dto: UpdateOpportunityDto) {
    return this.opportunitiesService.update(id, dto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    this.opportunitiesService.remove(id);
    return { message: 'åˆ é™¤æˆåŠŸ' };
  }
}
```

#### 5. åˆ›å»º Module

```typescript
// opportunities/opportunities.module.ts
@Module({
  controllers: [OpportunitiesController],
  providers: [OpportunitiesService, JsonStorageService],
})
export class OpportunitiesModule {}
```

#### 6. æ³¨å†Œåˆ°ä¸»æ¨¡å—

```typescript
// app.module.ts
@Module({
  imports: [
    AuthModule,
    CustomersModule,
    LeadsModule,
    ActivitiesModule,
    TasksModule,
    OpportunitiesModule,  // æ–°å¢
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

---

## ğŸ” API æ¥å£è§„èŒƒ

### RESTful è®¾è®¡

```
GET     /api/customers          è·å–å®¢æˆ·åˆ—è¡¨
GET     /api/customers/:id      è·å–å•ä¸ªå®¢æˆ·
POST    /api/customers          åˆ›å»ºå®¢æˆ·
PATCH   /api/customers/:id      æ›´æ–°å®¢æˆ·
DELETE  /api/customers/:id      åˆ é™¤å®¢æˆ·
```

### å“åº”æ ¼å¼

#### æˆåŠŸå“åº”

```json
// è¿”å›å•ä¸ªå¯¹è±¡
{
  "id": "uuid",
  "name": "å¼ ä¸‰",
  "phone": "13800138000",
  ...
}

// è¿”å›æ•°ç»„
[
  { "id": "1", "name": "å¼ ä¸‰" },
  { "id": "2", "name": "æå››" }
]
```

#### é”™è¯¯å“åº”

```json
{
  "statusCode": 400,
  "message": "è¯·å¡«å†™å¿…å¡«ä¿¡æ¯",
  "error": "Bad Request"
}
```

### HTTP çŠ¶æ€ç 

- `200` - æˆåŠŸ
- `201` - åˆ›å»ºæˆåŠŸ
- `400` - è¯·æ±‚å‚æ•°é”™è¯¯
- `401` - æœªç™»å½•
- `403` - æ— æƒé™
- `404` - èµ„æºä¸å­˜åœ¨
- `500` - æœåŠ¡å™¨é”™è¯¯

---

## ğŸ›¡ï¸ æƒé™æ§åˆ¶

### æ•°æ®æƒé™

```typescript
findAll(userId: string, userRole: string): Customer[] {
  const customers = this.storageService.read<Customer>('customers');
  
  // ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹æ‰€æœ‰æ•°æ®
  if (userRole === 'admin') {
    return customers;
  }
  
  // é”€å”®åªèƒ½æŸ¥çœ‹è‡ªå·±çš„æ•°æ®
  return customers.filter(customer => customer.ownerId === userId);
}
```

### æ“ä½œæƒé™

```typescript
update(id: string, dto: UpdateCustomerDto, userId: string, userRole: string): Customer {
  const customer = this.findOne(id, userId, userRole);
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™ç¼–è¾‘
  if (userRole !== 'admin' && customer.ownerId !== userId) {
    throw new ForbiddenException('æ— æƒç¼–è¾‘æ­¤å®¢æˆ·');
  }
  
  // æ‰§è¡Œæ›´æ–°
  return this.storageService.update('customers', id, dto);
}
```

---

## ğŸ› è°ƒè¯•æŠ€å·§

### 1. æ‰“å°æ—¥å¿—

```typescript
console.log('ç”¨æˆ· ID:', userId);
console.log('å®¢æˆ·æ•°æ®:', customer);
```

### 2. ä½¿ç”¨ Postman æµ‹è¯• API

```
1. åˆ›å»ºæ–°è¯·æ±‚
2. è®¾ç½®æ–¹æ³•å’Œ URLï¼šPOST http://localhost:3000/api/auth/login
3. æ·»åŠ è¯·æ±‚ä½“ï¼ˆJSONï¼‰ï¼š
   {
     "email": "test@example.com",
     "password": "123456"
   }
4. å‘é€è¯·æ±‚
5. å¤åˆ¶è¿”å›çš„ token
6. åœ¨å…¶ä»–è¯·æ±‚çš„ Headers ä¸­æ·»åŠ ï¼š
   Authorization: Bearer <token>
```

### 3. æŸ¥çœ‹æ•°æ®æ–‡ä»¶

```bash
# ç›´æ¥æŸ¥çœ‹ JSON æ–‡ä»¶
cat data/customers.json

# æ ¼å¼åŒ–è¾“å‡º
cat data/customers.json | python -m json.tool
```

---

## ğŸ“š å¸¸ç”¨å‘½ä»¤

```bash
# å¯åŠ¨å¼€å‘æœåŠ¡å™¨ï¼ˆçƒ­é‡è½½ï¼‰
npm run start:dev

# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
npm run build

# å¯åŠ¨ç”Ÿäº§æœåŠ¡å™¨
npm run start:prod

# è¿è¡Œæµ‹è¯•
npm run test

# ä»£ç æ ¼å¼åŒ–
npm run format

# ä»£ç æ£€æŸ¥
npm run lint
```

---

## ğŸ’¡ æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ TypeScript ç±»å‹

```typescript
// âŒ ä¸æ¨è
function createCustomer(data: any) {
  return this.storageService.create('customers', data);
}

// âœ… æ¨è
function createCustomer(data: CreateCustomerDto): Customer {
  const customer: Customer = {
    id: uuidv4(),
    ...data,
    createdAt: new Date().toISOString(),
  };
  return this.storageService.create('customers', customer);
}
```

### 2. é”™è¯¯å¤„ç†

```typescript
// âŒ ä¸æ¨è
function findOne(id: string) {
  return this.storageService.findById('customers', id);
}

// âœ… æ¨è
function findOne(id: string): Customer {
  const customer = this.storageService.findById<Customer>('customers', id);
  if (!customer) {
    throw new NotFoundException('å®¢æˆ·ä¸å­˜åœ¨');
  }
  return customer;
}
```

### 3. æ•°æ®éªŒè¯

```typescript
// ä½¿ç”¨ DTO å’ŒéªŒè¯è£…é¥°å™¨
export class CreateCustomerDto {
  @IsString()
  @IsNotEmpty()
  @MinLength(2)
  @MaxLength(50)
  name: string;

  @IsString()
  @IsNotEmpty()
  @Matches(/^1[3-9]\d{9}$/, { message: 'æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®' })
  phone: string;
}
```

### 4. å¼‚æ­¥æ“ä½œ

```typescript
// è™½ç„¶å½“å‰æ˜¯åŒæ­¥æ–‡ä»¶è¯»å†™ï¼Œä½†ä¿æŒå¼‚æ­¥é£æ ¼ä¾¿äºæœªæ¥æ‰©å±•
async findAll(userId: string, userRole: string): Promise<Customer[]> {
  const customers = this.storageService.read<Customer>('customers');
  // ...
  return customers;
}
```

---

## ğŸ”— ä¸‹ä¸€æ­¥

- å­¦ä¹  [å‰ç«¯å¼€å‘æŒ‡å—](./03-å‰ç«¯å¼€å‘æŒ‡å—.md)
- äº†è§£ [æ•°æ®å¤§å±å¼€å‘](./04-æ•°æ®å¤§å±å¼€å‘.md)
- æŸ¥çœ‹ [å¸¸è§é—®é¢˜FAQ](./05-å¸¸è§é—®é¢˜FAQ.md)
